#!/usr/bin/env groovy


// ## Optional semicolons
// 
// a = 3 + 1
// 
// b = 3
// + 1
// 
// c = 3\
// + 1
// 
// d = (3
// + 1)
// 
// println(a)
// println(b)
// println(c)
// println(d)
// 



def a(){ [b: 3]}
a() b


// // Leaving out dots
// 
// yoable = [yo:null]
// 
// def coolPrint(message) {
//     println(message)
//     yoable
// }
// 
// 
// coolPrint("s'up?")
// coolPrint("s'up?") yo
// 
// System.exit(0)


// ## Passing closures
// TODO: example of word { otherWord {} }

// x = {x -> println(x)}
// x("a")
// x("b")
// 
// y = {println(it)}
// y("c")
// 
// 
// def doItTwice(fn) {
//     fn()
//     fn()
// }
// 
// doItTwice({println("d")})
// 
// doItTwice {println("e")}


// ## String interpolation - see dontrunme?.groovy

// ## Omitting brackets

// def printArg(a) {
//     println(a)
// }
// 
// printArg(10)
// 
// printArg({println("Do I get run? A")})
// 
// printArg {
//     println("Do I get run? B")
// }
// 
//  def printArgs(a, b) {
//      println(a)
//      println(b)
//  }
// 
// printArgs(1, 2)
// printArgs 3, 4
// 
// printArgs(5) 6
// 
// printArgs(5) {println("do I get run?")}


// // ## Extension methods
// 
// 4.times {println("Andy is great")}
// 
// def letters = new TreeMap([
//     "a": 2,
//     "b": 3,
//     "c": 4,
//     "z": 1,
// ])
// 
// Map.metaClass.eachInValueOrder = {
//     entries = new ArrayList(entrySet())
//     entries.sort({e1, e2 -> e1.getValue() - e2.getValue()})
//     entries.each(it)
// }
// 
// println("Default order:")
// letters.each {println(it)}
// println("Value order:")
// letters.eachInValueOrder {println(it)}
// 
// // ## Operator overloading
// 
// // TODO: make level actually work
// 
// class MazeUnderScore {
//     def mod(MazeUnderScore other) {
//         this
//     }
//     def or(MazeUnderScore other) {
//         this
//     }
//     def plus(MazeUnderScore other) {
//         this
//     }
//     def multiply(MazeUnderScore other) {
//         this
//     }
//     def get_() {
//         new MazeUnderScore()
//     }
// }
// 
// def _ = new MazeUnderScore()
// 
// _%_%_%_%_%_%_%_%_%_%_%_%_%_%_%_%_%_
// _%_*_._._._._._._%_._._._._._._*_%_
// _%_._%_%_._%_._%_%_%_._%_._%_%_._%_
// _%_._._._._%_._._._._._%_._._._._._
// _%_%_%_%_._%_%_%_._%_%_%_._%_%_%_%_
// _._._._._._%_._|_._|_._%_._._._._._
// _%_%_%_%_._%_%_%_._%_%_%_._%_%_%_%_
// _%_._._._._%_._._._._._%_._._._._._
// _%_._%_%_._%_._%_%_%_._%_._%_%_._%_
// _%_*_+_._._._._._%_._._._._._._*_%_
// _%_%_%_%_%_%_%_%_%_%_%_%_%_%_%_%_%_
// 
// 
// class Arg {
//     String value
//     Arg(value) {
//         this.value = value
//     }
// 
//     String toString() {
//         value
//     }
// }
// 
// class Ghosts {
//     def mode = new Arg("ghosts.mode")
// }
// 
// class Rule {
//     def event
//     def object
//     def operation
//     Rule(event, object, operation) {
//         this.event = event
//         this.object = object
//         this.operation = operation
//     }
// 
//     String toString() {
//         "on(${event}, ${operation.name}(${object}, ${operation.arg}))"
//     }
// }
// 
// class Operation {
//     String name
//     String arg
//     Operation(name, arg) {
//         this.name = name
//         this.arg = arg
//     }
// }
// 
// class ObjectEvent {
//     def object
//     def trigger
//     ObjectEvent(object) {
//         this.object = object
//     }
//     String toString() {
//         "${object}.${trigger}"
//     }
// }
// 
// class Trigger {
//     def verb
//     def receiver
//     Trigger(verb, receiver) {
//         this.verb = verb
//         this.receiver = receiver
//     }
//     String toString() {
//         "${verb}(${receiver})"
//     }
// }
// 
// 
// class Logic {
// 
//     def rules = []
//     def currentEvent = null
//     def currentObject = null
//     def currentOperation = null
// 
//     def changeEvent(newEvent) {
//         if (!currentEvent.is(null)) {
//             changeObject(null)
//         }
//         currentEvent = newEvent
//         this
//     }
// 
//     def changeObject(newObject) {
//         assert !currentEvent.is(null)
//         if (!currentObject.is(null)) {
//             rules.add(new Rule(currentEvent, currentObject, currentOperation))
//         }
//         currentObject = newObject
//         this
//     }
// 
//     def changeOperation(op, arg) {
//         currentOperation = new Operation(op, arg)
//         this
//     }
// 
//     def at(time) {
//         changeEvent(time)
//     }
// 
//     def when(object) {
//         changeEvent(new ObjectEvent(object))
//     }
// 
//     def and(object) {
//         changeObject(object)
//     }
// 
//     def then(object) {
//         changeObject(object)
//     }
// 
//     def getDies() {
//         changeOperation("dies", null)
//     }
// 
//     def becomes(arg) {
//         changeOperation("setValue", arg)
//     }
// 
//     def hits(arg) {
//         currentEvent.trigger = new Trigger("hits", arg)
//         this
//     }
// 
//     def done() {
//         changeObject(null)
//     }
// }
// 
// 
// logic = new Logic()
// 
// ghost = new Arg("ghost")
// ghosts = new Ghosts()
// mode = new Arg("mode")
// normal = new Arg("normal")
// pill = new Arg("pill")
// player = new Arg("player")
// start = new Arg("start")
// scared = new Arg("scared")
// deleted = new Arg("deleted")
// done = "done"
// 
// def at(time) {
//     logic.at(time)
// }
// 
// def when(object) {
//     logic.when(object)
// }
// 
// def rules(arg) {
//     assert arg == "done"
//     logic.done()
// }
// 
// at start then ghosts.mode becomes normal
// when ghost hits player then player dies
// when player hits pill then ghosts.mode becomes scared and pill becomes deleted
// rules done
// 
// for (rule in logic.rules) {
//     println(rule)
// }
// 
// 
// 
// 
// 
// def b = 1
// def d = 1
// def f = 1
// def h = 1
// 
// def a(x) {
//     [
//         c: {
//             it1 -> [
//                 e: {
//                     it2 -> [g : {it3 -> []}]
//                 }
//             ]
//         }
//     ]
// }
// 
// 
// a b  c d  e f  g h
// a(b).c(d).e(f).g(h);
// 
